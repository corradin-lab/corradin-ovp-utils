# AUTOGENERATED! DO NOT EDIT! File to edit: 04_odds_ratio.ipynb (unless otherwise specified).

__all__ = ['RsidComboInfo', 'get_geno_combination_df', 'CaseControlOddsRatio', 'odds_ratio_calculator',
           'odds_ratio_df_single_combined', 'reconstruct_genetic_info']

# Cell
import pandas as pd
from typing import Any, Dict, List, Optional, Literal, Union
from dataclasses import dataclass
from fastcore.basics import basic_repr
from pydantic import BaseModel
from itertools import product
from ast import literal_eval
import numpy as np

# Cell

@dataclass
class RsidComboInfo():
    df: pd.DataFrame
    rsid_list: List[str]
    NA_val: str
    __repr__ = basic_repr("rsid_list,NA_val")

    #TODO: Query does not work when rsid is a number, need to find a way around that
    def query(self, **rsid_dict):
        if not all([rsid in self.rsid_list for rsid in rsid_dict.keys()]):
            raise ValueError("Some Rsid are not in the dataframe")
        filtered_df = self.df.copy()
        for rsid, geno in rsid_dict.items():
            filtered_df = filtered_df.query(f"{rsid} == '{geno}'")
        return filtered_df

    def get_all_genos(self, rsid:str):
        return self.df[rsid].unique()

    @property
    def total_samples_with_NA(self):
        return self.df.unique_samples_count.sum()

    @property
    def num_samples_NA(self):
        return self.df.loc[(self.df[self.rsid_list] == self.NA_val).any(axis=1)].unique_samples_count.sum()
    @property
    def total_samples_no_NA(self):
        return self.total_samples_with_NA  - self.num_samples_NA

def get_geno_combination_df(geno_each_sample_df: pd.DataFrame, rsid_list:List[str], NA_val="NA", as_df= False):
    #geno_each_sample_df[["rs77948203", "rs1014626", "rs1004237"]].reset_index().groupby(["rs77948203", "rs1014626", "rs1004237"])["sample_id"].unique().reset_index()
    geno_combination_df = geno_each_sample_df[rsid_list].fillna(NA_val).reset_index().groupby(rsid_list)["sample_id"].agg(**{"unique_samples_id":"unique", "unique_samples_count": "nunique"}).reset_index()
    if as_df:
        return geno_combination_df
    else:
        info_obj = RsidComboInfo(df= geno_combination_df, rsid_list = rsid_list, NA_val= NA_val)
    return info_obj


# Cell
class CaseControlOddsRatio(BaseModel):
    case: RsidComboInfo
    control: RsidComboInfo
    geno_df: pd.DataFrame


#     def __init__(self, *, case_df, control_df, geno_df):

    @property
    def snp_cols(self):
        case_snp_cols = self.case.df.columns.difference(['unique_samples_id', 'unique_samples_count'])
        control_snp_cols = self.control.df.columns.difference(['unique_samples_id', 'unique_samples_count'])
        assert set(case_snp_cols) == set(control_snp_cols)
        snp_cols_sorted = sorted(list(set(case_snp_cols)))
        return snp_cols_sorted

    @property
    def possible_genotypes_single(self):
        return self.geno_df[["AA", "AB", "BB"]]

    @property
    def possible_genotypes_combo(self):
        geno_combo_df = pd.DataFrame(product(*[self.possible_genotypes_single.loc[rsid].tolist()
                        for rsid in self.possible_genotypes_single.index]), columns = self.possible_genotypes_single.index)
        return geno_combo_df

    @property
    def case_total_no_NA(self):
        return self.case.total_samples_no_NA

    @property
    def case_total_with_NA(self):
        return self.case.total_samples_with_NA

    @property
    def control_total_no_NA(self):
        return self.control.total_samples_no_NA

    @property
    def control_total_with_NA(self):
        return self.control.total_samples_with_NA


    def calculate_odds_ratio(self, query_geno_dict: Dict[str, str], ndigits = 5):
        try:
            geno_case = self.case.query(**query_geno_dict).unique_samples_count.item()
        # except ValueError:
        #     print(self.case.query(**query_geno_dict).unique_samples_count)
        #try:
            geno_control = self.control.query(**query_geno_dict).unique_samples_count.item()
        # except ValueError:
        #     print(self.control.query(**query_geno_dict).unique_samples_count)
            odds_ratio = odds_ratio_calculator(geno_case= geno_case,
                                  geno_control=geno_control,
                                  case_total_no_NA = self.case_total_no_NA,
                                  control_total_no_NA = self.control_total_no_NA)
            odds_ratio_rounded = round(odds_ratio, ndigits = ndigits)
        except ValueError:
            return np.nan
        return odds_ratio_rounded

    @property
    def odds_ratios_df(self):
        odds_ratio = [self.calculate_odds_ratio(query_dict) for query_dict in self.possible_genotypes_combo.to_dict(orient="records")]
        odds_ratio_df = self.possible_genotypes_combo.assign(odds_ratio = odds_ratio)
        return odds_ratio_df


    class Config:
        arbitrary_types_allowed = True


def odds_ratio_calculator(geno_case, geno_control, case_total_no_NA, control_total_no_NA):
        """
        calculates odds ratio using formula specified by type of pipeline
        """
        try:
#             if self.odds_ratio_type == 1:
            case_odds = geno_case / (case_total_no_NA - geno_case)
            control_odds = geno_control / (control_total_no_NA - geno_control)
#             else:
#                 case_odds = case / case_total
#                 control_odds = control / control_total

            odds_ratio = case_odds / control_odds
#             if odds_ratio == 0:
#                 odds_ratio = "NA"

            return odds_ratio
        except ZeroDivisionError:
            return "NA"

# Cell
def odds_ratio_df_single_combined(*,case_geno_each_sample:pd.DataFrame, control_geno_each_sample:pd.DataFrame, all_geno_df:pd.DataFrame, single_rsid:str, combo_rsid_list:List[str]):
    """ `combo_rsid_list` has to contain `single_rsid`
    """
    assert single_rsid in combo_rsid_list

    test_case_control_odds_ratio_single = CaseControlOddsRatio(case = get_geno_combination_df(case_geno_each_sample, [single_rsid]),
                        control =  get_geno_combination_df(control_geno_each_sample, [single_rsid]),
                        geno_df = all_geno_df.loc[[single_rsid]])

    test_case_control_odds_ratio_combo = CaseControlOddsRatio(case = get_geno_combination_df(case_geno_each_sample, combo_rsid_list),
                        control =  get_geno_combination_df(control_geno_each_sample, combo_rsid_list),
                        geno_df = all_geno_df.loc[combo_rsid_list])

    odds_ratio_df_combined = test_case_control_odds_ratio_combo.odds_ratios_df.merge(test_case_control_odds_ratio_single.odds_ratios_df, on = single_rsid, suffixes = ["_combo", "_single"])
    #odds_ratio_df_combined = odds_ratio_df_combined.reset_index(drop=True)
    odds_ratio_df_combined = odds_ratio_df_combined.merge(test_case_control_odds_ratio_combo.case.df, on = combo_rsid_list, how = "left")
    odds_ratio_df_combined = odds_ratio_df_combined.merge(test_case_control_odds_ratio_combo.control.df, on = combo_rsid_list, how = "left", suffixes = ["_case", "_control"])

    odds_ratio_df_combined["case_total_no_NA"] = test_case_control_odds_ratio_combo.case_total_no_NA
    odds_ratio_df_combined["case_total_with_NA"] = test_case_control_odds_ratio_combo.case_total_with_NA
    odds_ratio_df_combined["control_total_no_NA"] = test_case_control_odds_ratio_combo.control_total_no_NA
    odds_ratio_df_combined["control_total_with_NA"] = test_case_control_odds_ratio_combo.control_total_with_NA


    return odds_ratio_df_combined

# Cell
def reconstruct_genetic_info(summary_df, rsid_list:List[str], exclude_NA=True):
    #TODO: handle the case where no sample ids are provided
    summary_df_copy = summary_df.copy()

    if exclude_NA:
        summary_df_copy = summary_df_copy.loc[summary_df_copy.notna().all(axis=1),:]

    case_geno_each_sample_reconstructed = summary_df_copy.loc[:, rsid_list + ["unique_samples_id_case"]].explode("unique_samples_id_case")
    case_geno_each_sample_reconstructed = case_geno_each_sample_reconstructed.set_index("unique_samples_id_case")
    case_geno_each_sample_reconstructed.index.name = "sample_id"
    control_geno_each_sample_reconstructed = summary_df_copy.loc[:, rsid_list + ["unique_samples_id_control"]].explode("unique_samples_id_control")
    control_geno_each_sample_reconstructed = control_geno_each_sample_reconstructed.set_index("unique_samples_id_control")
    control_geno_each_sample_reconstructed.index.name = "sample_id"
    return {"case_geno_each_sample": case_geno_each_sample_reconstructed, "control_geno_each_sample": control_geno_each_sample_reconstructed}